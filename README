**Title:**
Advisory: Potential Heap Corruption in SMB2 Preauth Integrity and SPNEGO/NTLMSSP Parsing

---

**Summary:**
We have identified conditions under which a carefully crafted SMB2 authentication exchange can trigger a heap‑based memory corruption in the server’s handling of Preauth Integrity Capabilities and SPNEGO‑wrapped NTLMSSP tokens. The flaw arises from mismatched length and offset fields in negotiate contexts and SSPI buffers, leading to unbounded copies into undersized allocations.

---

**Technical Details (high‑level):**

1. **SMB2 Preauth Integrity Context Mis‑copy**
   In the SMB2 “CreateContexts” handler, the server computes a total blob size (`uVar17`) by summing each context’s advertised length—EA list, names, headers, and salt—then allocates a heap buffer accordingly. However, when handling the Preauth Integrity (salt) context, it re‑uses the *global* `CreateContextsLength` for the final `memmove`, rather than the salt’s own DataLength. This copies the entire attacker‑controlled blob into a much smaller buffer, overrunning the heap .

2. **SPNEGO Wrapper / OID Handling in ksecdd.sys → LSASS**
   The SPNEGO layer (`spnego.dll`/`ksecdd.sys`) selects NTLM and hands the raw blob via IOCTL to LSASS. Inside `msv1_0.dll`, the entry point at `FUN_180001920` performs:

   ```c
   memcpy(ctx, SecBuffer, dataLen);
   strncmp((char*)ctx, "NTLMSSP", 8);
   ```

   but does **not** validate that `dataLen` ≤ the 0x160‑byte heap context, allowing a larger SPNEGO token to overflow this buffer .

3. **Type 2 (“Challenge”) Output‑Buffer Bounds Omission**
   When building the NTLM Challenge (`FUN_1800234F8`), the code writes out 8 bytes of `"NTLMSSP\0"` and the random challenge without checking the caller’s output‑buffer size. A too‑small buffer can be overrun, leading to adjacent memory corruption .

---

**Impact:**
A remote, unauthenticated attacker with network access to TCP 445 can provoke unbounded heap writes in kernel mode (SMB2 create‑contexts) or user mode (SPNEGO/NTLMSSP) by sending malformed NEGOTIATE or SESSION\_SETUP messages. This may result in denial‑of‑service or, with suitable heap grooming, arbitrary code execution under elevated privileges.




